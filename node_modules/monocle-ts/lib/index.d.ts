import { HKT, URIS, URIS2, URIS3, Type, Type2, Type3 } from 'fp-ts/lib/HKT';
import { Monoid } from 'fp-ts/lib/Monoid';
import { Applicative, Applicative1, Applicative2, Applicative3, Applicative2C, Applicative3C } from 'fp-ts/lib/Applicative';
import { Foldable, Foldable1, Foldable2, Foldable3 } from 'fp-ts/lib/Foldable';
import { Traversable, Traversable1, Traversable2, Traversable3 } from 'fp-ts/lib/Traversable';
import { Option } from 'fp-ts/lib/Option';
import { Predicate } from 'fp-ts/lib/function';
export declare class Iso<S, A> {
    readonly get: (s: S) => A;
    readonly reverseGet: (a: A) => S;
    readonly _tag: 'Iso';
    constructor(get: (s: S) => A, reverseGet: (a: A) => S);
    /** reverse the `Iso`: the source becomes the target and the target becomes the source */
    reverse(): Iso<A, S>;
    modify(f: (a: A) => A): (s: S) => S;
    /** view an Iso as a Lens */
    asLens(): Lens<S, A>;
    /** view an Iso as a Prism */
    asPrism(): Prism<S, A>;
    /** view an Iso as a Optional */
    asOptional(): Optional<S, A>;
    /** view an Iso as a Traversal */
    asTraversal(): Traversal<S, A>;
    /** view an Iso as a Fold */
    asFold(): Fold<S, A>;
    /** view an Iso as a Getter */
    asGetter(): Getter<S, A>;
    /** view an Iso as a Setter */
    asSetter(): Setter<S, A>;
    /** compose an Iso with an Iso */
    compose<B>(ab: Iso<A, B>): Iso<S, B>;
    /** compose an Iso with a Lens */
    composeLens<B>(ab: Lens<A, B>): Lens<S, B>;
    /** compose an Iso with a Prism */
    composePrism<B>(ab: Prism<A, B>): Prism<S, B>;
    /** compose an Iso with an Optional */
    composeOptional<B>(ab: Optional<A, B>): Optional<S, B>;
    /** compose an Iso with a Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Traversal<S, B>;
    /** compose an Iso with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose an Iso with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Getter<S, B>;
    /** compose an Iso with a Setter */
    composeSetter<B>(ab: Setter<A, B>): Setter<S, B>;
}
export interface Iso<S, A> {
    unwrap: (s: S) => A;
    to: (s: S) => A;
    wrap: (a: A) => S;
    from: (a: A) => S;
}
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6], K8 extends keyof T[K1][K2][K3][K4][K5][K6][K7], K9 extends keyof T[K1][K2][K3][K4][K5][K6][K7][K8], K10 extends keyof T[K1][K2][K3][K4][K5][K6][K7][K8][K9]>(path: [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10]): Lens<T, T[K1][K2][K3][K4][K5][K6][K7][K8][K9][K10]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6], K8 extends keyof T[K1][K2][K3][K4][K5][K6][K7], K9 extends keyof T[K1][K2][K3][K4][K5][K6][K7][K8]>(path: [K1, K2, K3, K4, K5, K6, K7, K8, K9]): Lens<T, T[K1][K2][K3][K4][K5][K6][K7][K8][K9]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6], K8 extends keyof T[K1][K2][K3][K4][K5][K6][K7]>(path: [K1, K2, K3, K4, K5, K6, K7, K8]): Lens<T, T[K1][K2][K3][K4][K5][K6][K7][K8]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6]>(path: [K1, K2, K3, K4, K5, K6, K7]): Lens<T, T[K1][K2][K3][K4][K5][K6][K7]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(path: [K1, K2, K3, K4, K5, K6]): Lens<T, T[K1][K2][K3][K4][K5][K6]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(path: [K1, K2, K3, K4, K5]): Lens<T, T[K1][K2][K3][K4][K5]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(path: [K1, K2, K3, K4]): Lens<T, T[K1][K2][K3][K4]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(path: [K1, K2, K3]): Lens<T, T[K1][K2][K3]>;
export declare function lensFromPath<T, K1 extends keyof T, K2 extends keyof T[K1]>(path: [K1, K2]): Lens<T, T[K1][K2]>;
export declare function lensFromPath<T, K1 extends keyof T>(path: [K1]): Lens<T, T[K1]>;
export declare class Lens<S, A> {
    readonly get: (s: S) => A;
    readonly set: (a: A) => (s: S) => S;
    static fromPath: typeof lensFromPath;
    readonly _tag: 'Lens';
    constructor(get: (s: S) => A, set: (a: A) => (s: S) => S);
    /** generate a lens from a type and a prop */
    static fromProp<T, P extends keyof T>(prop: P): Lens<T, T[P]>;
    /** generate a lens from a type and an array of props */
    static fromProps<S>(): <P extends keyof S>(props: Array<P>) => Lens<S, {
        [K in P]: S[K];
    }>;
    /** generate a lens from a type and a prop whose type is nullable */
    static fromNullableProp<S, A extends S[K], K extends keyof S>(k: K, defaultValue: A): Lens<S, A>;
    modify(f: (a: A) => A): (s: S) => S;
    /** view a Lens as a Optional */
    asOptional(): Optional<S, A>;
    /** view a Lens as a Traversal */
    asTraversal(): Traversal<S, A>;
    /** view a Lens as a Setter */
    asSetter(): Setter<S, A>;
    /** view a Lens as a Getter */
    asGetter(): Getter<S, A>;
    /** view a Lens as a Fold */
    asFold(): Fold<S, A>;
    /** compose a Lens with a Lens */
    compose<B>(ab: Lens<A, B>): Lens<S, B>;
    /** compose a Lens with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Getter<S, B>;
    /** compose a Lens with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose a Lens with an Optional */
    composeOptional<B>(ab: Optional<A, B>): Optional<S, B>;
    /** compose a Lens with an Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Traversal<S, B>;
    /** compose a Lens with an Setter */
    composeSetter<B>(ab: Setter<A, B>): Setter<S, B>;
    /** compose a Lens with an Iso */
    composeIso<B>(ab: Iso<A, B>): Lens<S, B>;
    /** compose a Lens with a Prism */
    composePrism<B>(ab: Prism<A, B>): Optional<S, B>;
}
export declare class Prism<S, A> {
    readonly getOption: (s: S) => Option<A>;
    readonly reverseGet: (a: A) => S;
    readonly _tag: 'Prism';
    constructor(getOption: (s: S) => Option<A>, reverseGet: (a: A) => S);
    static fromPredicate<A>(predicate: Predicate<A>): Prism<A, A>;
    static some<A>(): Prism<Option<A>, A>;
    modify(f: (a: A) => A): (s: S) => S;
    modifyOption(f: (a: A) => A): (s: S) => Option<S>;
    /** set the target of a Prism with a value */
    set(a: A): (s: S) => S;
    /** view a Prism as a Optional */
    asOptional(): Optional<S, A>;
    /** view a Prism as a Traversal */
    asTraversal(): Traversal<S, A>;
    /** view a Prism as a Setter */
    asSetter(): Setter<S, A>;
    /** view a Prism as a Fold */
    asFold(): Fold<S, A>;
    /** compose a Prism with a Prism */
    compose<B>(ab: Prism<A, B>): Prism<S, B>;
    /** compose a Prism with a Optional */
    composeOptional<B>(ab: Optional<A, B>): Optional<S, B>;
    /** compose a Prism with a Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Traversal<S, B>;
    /** compose a Prism with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose a Prism with a Setter */
    composeSetter<B>(ab: Setter<A, B>): Setter<S, B>;
    /** compose a Prism with a Iso */
    composeIso<B>(ab: Iso<A, B>): Prism<S, B>;
    /** compose a Prism with a Lens */
    composeLens<B>(ab: Lens<A, B>): Optional<S, B>;
    /** compose a Prism with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Fold<S, B>;
}
export declare class Optional<S, A> {
    readonly getOption: (s: S) => Option<A>;
    readonly set: (a: A) => (s: S) => S;
    readonly _tag: 'Optional';
    constructor(getOption: (s: S) => Option<A>, set: (a: A) => (s: S) => S);
    static fromNullableProp: <S_1, A_1 extends S_1[K], K extends keyof S_1>(k: K) => Optional<S_1, A_1>;
    modify(f: (a: A) => A): (s: S) => S;
    modifyOption(f: (a: A) => A): (s: S) => Option<S>;
    /** view a Optional as a Traversal */
    asTraversal(): Traversal<S, A>;
    /** view an Optional as a Fold */
    asFold(): Fold<S, A>;
    /** view an Optional as a Setter */
    asSetter(): Setter<S, A>;
    /** compose a Optional with a Optional */
    compose<B>(ab: Optional<A, B>): Optional<S, B>;
    /** compose an Optional with a Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Traversal<S, B>;
    /** compose an Optional with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose an Optional with a Setter */
    composeSetter<B>(ab: Setter<A, B>): Setter<S, B>;
    /** compose an Optional with a Lens */
    composeLens<B>(ab: Lens<A, B>): Optional<S, B>;
    /** compose an Optional with a Prism */
    composePrism<B>(ab: Prism<A, B>): Optional<S, B>;
    /** compose an Optional with a Iso */
    composeIso<B>(ab: Iso<A, B>): Optional<S, B>;
    /** compose an Optional with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Fold<S, B>;
}
export interface ModifyF<S, A> {
    <F extends URIS3>(F: Applicative3<F>): <U, L>(f: (a: A) => Type3<F, U, L, A>) => (s: S) => Type3<F, U, L, S>;
    <F extends URIS3, U, L>(F: Applicative3C<F, U, L>): (f: (a: A) => Type3<F, U, L, A>) => (s: S) => Type3<F, U, L, S>;
    <F extends URIS2>(F: Applicative2<F>): <L>(f: (a: A) => Type2<F, L, A>) => (s: S) => Type2<F, L, S>;
    <F extends URIS2, L>(F: Applicative2C<F, L>): (f: (a: A) => Type2<F, L, A>) => (s: S) => Type2<F, L, S>;
    <F extends URIS>(F: Applicative1<F>): (f: (a: A) => Type<F, A>) => (s: S) => Type<F, S>;
    <F>(F: Applicative<F>): (f: (a: A) => HKT<F, A>) => (s: S) => HKT<F, S>;
}
export declare class Traversal<S, A> {
    readonly modifyF: ModifyF<S, A>;
    readonly _tag: 'Traversal';
    constructor(modifyF: ModifyF<S, A>);
    modify(f: (a: A) => A): (s: S) => S;
    set(a: A): (s: S) => S;
    /** view a Traversal as a Fold */
    asFold(): Fold<S, A>;
    /** view a Traversal as a Setter */
    asSetter(): Setter<S, A>;
    /** compose a Traversal with a Traversal */
    compose<B>(ab: Traversal<A, B>): Traversal<S, B>;
    /** compose a Traversal with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose a Traversal with a Setter */
    composeSetter<B>(ab: Setter<A, B>): Setter<S, B>;
    /** compose a Traversal with a Optional */
    composeOptional<B>(ab: Optional<A, B>): Traversal<S, B>;
    /** compose a Traversal with a Lens */
    composeLens<B>(ab: Lens<A, B>): Traversal<S, B>;
    /** compose a Traversal with a Prism */
    composePrism<B>(ab: Prism<A, B>): Traversal<S, B>;
    /** compose a Traversal with a Iso */
    composeIso<B>(ab: Iso<A, B>): Traversal<S, B>;
    /** compose a Traversal with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Fold<S, B>;
}
export declare class Getter<S, A> {
    readonly get: (s: S) => A;
    readonly _tag: 'Getter';
    constructor(get: (s: S) => A);
    /** view a Getter as a Fold */
    asFold(): Fold<S, A>;
    /** compose a Getter with a Getter */
    compose<B>(ab: Getter<A, B>): Getter<S, B>;
    /** compose a Getter with a Fold */
    composeFold<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose a Getter with a Lens */
    composeLens<B>(ab: Lens<A, B>): Getter<S, B>;
    /** compose a Getter with a Iso */
    composeIso<B>(ab: Iso<A, B>): Getter<S, B>;
    /** compose a Getter with a Optional */
    composeTraversal<B>(ab: Traversal<A, B>): Fold<S, B>;
    /** compose a Getter with a Optional */
    composeOptional<B>(ab: Optional<A, B>): Fold<S, B>;
    /** compose a Getter with a Prism */
    composePrism<B>(ab: Prism<A, B>): Fold<S, B>;
}
export declare class Fold<S, A> {
    readonly foldMap: <M>(M: Monoid<M>) => (f: (a: A) => M) => (s: S) => M;
    readonly _tag: 'Fold';
    private foldMapFirst;
    constructor(foldMap: <M>(M: Monoid<M>) => (f: (a: A) => M) => (s: S) => M);
    /** compose a Fold with a Fold */
    compose<B>(ab: Fold<A, B>): Fold<S, B>;
    /** compose a Fold with a Getter */
    composeGetter<B>(ab: Getter<A, B>): Fold<S, B>;
    /** compose a Fold with a Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Fold<S, B>;
    /** compose a Fold with a Optional */
    composeOptional<B>(ab: Optional<A, B>): Fold<S, B>;
    /** compose a Fold with a Lens */
    composeLens<B>(ab: Lens<A, B>): Fold<S, B>;
    /** compose a Fold with a Prism */
    composePrism<B>(ab: Prism<A, B>): Fold<S, B>;
    /** compose a Fold with a Iso */
    composeIso<B>(ab: Iso<A, B>): Fold<S, B>;
    /** find the first target of a Fold matching the predicate */
    find(p: Predicate<A>): (s: S) => Option<A>;
    /** get the first target of a Fold */
    headOption(s: S): Option<A>;
}
export interface Fold<S, A> {
    /** get all the targets of a Fold */
    getAll(s: S): Array<A>;
    /** check if at least one target satisfies the predicate */
    exist(p: Predicate<A>): Predicate<S>;
    /** check if all targets satisfy the predicate */
    all(p: Predicate<A>): Predicate<S>;
}
export declare class Setter<S, A> {
    readonly modify: (f: (a: A) => A) => (s: S) => S;
    readonly _tag: 'Setter';
    constructor(modify: (f: (a: A) => A) => (s: S) => S);
    set(a: A): (s: S) => S;
    /** compose a Setter with a Setter */
    compose<B>(ab: Setter<A, B>): Setter<S, B>;
    /** compose a Setter with a Traversal */
    composeTraversal<B>(ab: Traversal<A, B>): Setter<S, B>;
    /** compose a Setter with a Optional */
    composeOptional<B>(ab: Optional<A, B>): Setter<S, B>;
    /** compose a Setter with a Lens */
    composeLens<B>(ab: Lens<A, B>): Setter<S, B>;
    /** compose a Setter with a Prism */
    composePrism<B>(ab: Prism<A, B>): Setter<S, B>;
    /** compose a Setter with a Iso */
    composeIso<B>(ab: Iso<A, B>): Setter<S, B>;
}
/** create a Traversal from a Traversable */
export declare function fromTraversable<T extends URIS3>(T: Traversable3<T>): <U, L, A>() => Traversal<Type3<T, U, L, A>, A>;
export declare function fromTraversable<T extends URIS2>(T: Traversable2<T>): <L, A>() => Traversal<Type2<T, L, A>, A>;
export declare function fromTraversable<T extends URIS>(T: Traversable1<T>): <A>() => Traversal<Type<T, A>, A>;
export declare function fromTraversable<T>(T: Traversable<T>): <A>() => Traversal<HKT<T, A>, A>;
/** create a Fold from a Foldable */
export declare function fromFoldable<F extends URIS3>(F: Foldable3<F>): <U, L, A>() => Fold<Type3<F, U, L, A>, A>;
export declare function fromFoldable<F extends URIS2>(F: Foldable2<F>): <L, A>() => Fold<Type2<F, L, A>, A>;
export declare function fromFoldable<F extends URIS>(F: Foldable1<F>): <A>() => Fold<Type<F, A>, A>;
export declare function fromFoldable<F>(F: Foldable<F>): <A>() => Fold<HKT<F, A>, A>;
