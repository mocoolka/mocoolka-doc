"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var glob_1 = require("glob");
var fs = require("fs");
var pathR = require("path");
var IO_1 = require("mocoolka-fp/lib/IO");
exports.pathResolve = function (root) { return function (sub) { return pathR.resolve(root, sub); }; };
exports.statSync = function (path) {
    return new IO_1.IO(function () { return Object.assign(fs.statSync(path), { path: path }); });
};
exports.isSubPath = function (parent, sub) { return !(pathR.relative(parent, sub).indexOf('..') >= 0); };
exports.readDirSync = function (path) {
    return new IO_1.IO(function () { return fs.readdirSync(path); });
};
exports.createDirNotExistSync = function (path) {
    return exports.directoryExistSync(path).map(function (a) { return !a ? fs.mkdirSync(path) : undefined; });
};
exports.directoryExistSync = function (path) {
    return new IO_1.IO(function () { return fs.existsSync(path) && fs.statSync(path).isDirectory(); });
};
exports.rmdirSync = function (strPath) {
    return new IO_1.IO(function () {
        if (exports.directoryExistSync(strPath).run()) {
            fs.readdirSync(strPath).forEach(function (file) {
                var curPath = pathR.resolve(strPath, file);
                if (fs.lstatSync(curPath).isDirectory()) {
                    exports.rmdirSync(curPath);
                }
                else {
                    exports.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(strPath);
        }
    });
};
exports.readFileAsStringSync = function (fileName) { return function (path) {
    return new IO_1.IO(function () { return fs.readFileSync(pathR.resolve(path, fileName)).toString('utf8'); });
}; };
exports.readFileAsPlainStringSync = function (path) {
    return new IO_1.IO(function () { return fs.readFileSync(path).toString('utf8'); });
};
exports.writeFileWithStringSync = function (filename, contents) { return function (path) {
    return exports.createDirNotExistSync(path).map(function () { return fs.writeFileSync(pathR.resolve(path, filename), contents, { encoding: 'utf-8' }); });
}; };
exports.fileExistSync = function (path) {
    return new IO_1.IO(function () { return fs.existsSync(path) && fs.statSync(path).isFile(); });
};
exports.unlinkSync = function (fileName) { return function (rootPath) {
    return new IO_1.IO(function () {
        fs.unlinkSync(exports.pathResolve(rootPath)(fileName));
    });
}; };
exports.filesSync = function (rootPath) { return function (name) {
    return new IO_1.IO(function () { return glob_1.sync(name, { cwd: rootPath, nonull: false }); });
}; };
exports.directoryDepth = function (strPath) {
    strPath = pathR.normalize(strPath);
    return strPath.split(pathR.sep).length;
};
exports.getDirectoryName = function (strPath) {
    return pathR.parse(strPath).dir;
};
exports.getFileName = function (strPath) {
    return pathR.parse(strPath).base;
};
exports.isFullPath = function (strRoot, strPath) {
    return pathR.resolve(strRoot, strPath) === strPath;
};
exports.realPathSync = function (strPath) {
    return fs.realpathSync(strPath);
};
exports.unSymbolLinkSync = function (strPath) {
    if (!strPath) {
        return null;
    }
    var stats = null;
    try {
        stats = fs.lstatSync(strPath);
    }
    catch (e) {
        return null;
    }
    if (!stats) {
        return null;
    }
    if (stats.isSymbolicLink()) {
        var _realPath = exports.realPathSync(strPath);
        return exports.unSymbolLinkSync(_realPath);
    }
    else {
        return stats.isDirectory() ? strPath : null;
    }
};
//# sourceMappingURL=sync.js.map