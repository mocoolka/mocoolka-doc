"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("io-ts"));
var t = require("io-ts");
var Monocle_1 = require("./Monocle");
var PathReporter_1 = require("io-ts/lib/PathReporter");
exports.PathReporter = PathReporter_1.PathReporter;
exports.successReporter = PathReporter_1.success;
exports.failureReporter = PathReporter_1.failure;
var ThrowReporter_1 = require("io-ts/lib/ThrowReporter");
exports.ThrowReporter = ThrowReporter_1.ThrowReporter;
exports.decodeFromAny = function (type) { return function (a) {
    var v = type.decode(a);
    ThrowReporter_1.ThrowReporter.report(v);
    return v.fold(function () { return void 0; }, function (a1) { return a1; });
}; };
/**
 * apply a default value when the value is null.
 * @param type
 * @param defaultValue
 */
exports.withDefault = function (type, defaultValue) {
    return new t.Type("withDefault(" + type.name + ", " + JSON.stringify(defaultValue) + ")", type.is, function (v, c) { return type.validate(v != null ? v : defaultValue, c); }, type.encode);
};
/**
 * The type input is number,The output is Date.
 */
var DateFromNumberType = /** @class */ (function (_super) {
    __extends(DateFromNumberType, _super);
    function DateFromNumberType() {
        var _this = _super.call(this, 'DateFromNumber', function (m) { return m instanceof Date; }, function (m, c) {
            var validation = t.number.validate(m, c);
            if (validation.isLeft()) {
                return validation;
            }
            else {
                var n = validation.value;
                var d = new Date(n);
                return isNaN(d.getTime()) ? t.failure(n, c) : t.success(d);
            }
        }, function (a) { return a.getTime(); }) || this;
        _this._tag = 'DateFromNumberType';
        return _this;
    }
    return DateFromNumberType;
}(t.Type));
exports.DateFromNumberType = DateFromNumberType;
exports.dateFromNumber = new DateFromNumberType();
/**
 * The type input is ISOString,output type is Date.
 */
var DateFromISOStringType = /** @class */ (function (_super) {
    __extends(DateFromISOStringType, _super);
    function DateFromISOStringType() {
        var _this = _super.call(this, 'DateFromISOString', function (m) { return m instanceof Date; }, function (m, c) {
            var validation = t.string.validate(m, c);
            if (validation.isLeft()) {
                return validation;
            }
            else {
                var s = validation.value;
                var d = new Date(s);
                return isNaN(d.getTime()) ? t.failure(s, c) : t.success(d);
            }
        }, function (a) { return a.toISOString(); }) || this;
        _this._tag = 'DateFromISOStringType';
        return _this;
    }
    return DateFromISOStringType;
}(t.Type));
exports.DateFromISOStringType = DateFromISOStringType;
exports.dateFromISOString = new DateFromISOStringType();
exports.lensesFromProps = function (props) {
    var r = {};
    Object.keys(props).forEach(function (k) {
        r[k] = Monocle_1.Lens.fromProp(k);
    });
    return r;
};
exports.lensesFromNullableProps = function (props) {
    var r = {};
    Object.keys(props).forEach(function (k) {
        r[k] = Monocle_1.Optional.fromNullableProp(k);
    });
    return r;
};
exports.integer = t.Integer;
exports.RRuntimeBasic = t.union([t.string, t.number, exports.integer, t.boolean, exports.dateFromISOString, exports.dateFromNumber]);
exports.RString = t.literal('string');
exports.RNumber = t.literal('number');
exports.RInteger = t.literal('integer');
exports.RBoolean = t.literal('boolean');
exports.RAny = t.literal('any');
exports.RDateFromISOString = t.literal('dateFromISOString');
exports.RDateFromNumber = t.literal('dateFromNumber');
exports.RBasicType = t.union([
    exports.RString,
    exports.RNumber,
    exports.RInteger,
    exports.RBoolean,
    exports.RDateFromISOString,
    exports.RDateFromNumber,
]);
exports.RBasicAnyType = t.union([
    exports.RBasicType,
    exports.RAny,
]);
exports.RBasicTypeArray = t.tuple([exports.RBasicType]);
exports.RInputBasicType = t.union([exports.RBasicAnyType, exports.RBasicTypeArray]);
exports.RBasicIType = t.union([exports.RBasicAnyType, t.string]);
exports.RTypeArray = t.tuple([exports.RBasicIType]);
exports.RInputType = t.union([exports.RBasicIType, exports.RTypeArray]);
exports.RSchemaType = t.type({
    name: exports.RBasicIType,
    isArray: t.boolean,
});
/**
 * The type input is number,The output is Date.
 */
var TypeFromStringType = /** @class */ (function (_super) {
    __extends(TypeFromStringType, _super);
    function TypeFromStringType() {
        var _this = _super.call(this, 'TypeFromString', function (m) { return exports.RBasicIType.is(m); }, function (m, c) {
            var validation = exports.RInputType.validate(m, c);
            if (validation.isLeft()) {
                return validation;
            }
            else {
                var n = validation.value;
                return t.success({
                    name: exports.RBasicIType.is(n) ? n : n[0],
                    isArray: exports.RTypeArray.is(n),
                });
            }
        }, function (a) { return a.isArray ? [a.name] : a.name; }) || this;
        _this._tag = 'TypeFromStringType';
        return _this;
    }
    return TypeFromStringType;
}(t.Type));
exports.TypeFromStringType = TypeFromStringType;
exports.typeFromString = new TypeFromStringType();
exports.basicTypeRuntime = {
    string: t.string,
    number: t.number,
    integer: exports.integer,
    boolean: t.boolean,
    dateFromISOString: exports.dateFromISOString,
    dateFromNumber: exports.dateFromNumber,
    any: t.any,
};
/**
 * Get type with string
 */
exports.BasicGetter = new Monocle_1.Getter(function (name) { return exports.basicTypeRuntime[name]; });
exports.lensesFromIntersection = function (_intersection) {
    return {
        props: exports.lensesFromProps(_intersection.types[0].props),
        nullProps: exports.lensesFromNullableProps(_intersection.types[1].props),
    };
};
//# sourceMappingURL=Type.js.map