export * from 'io-ts';
import * as t from 'io-ts';
import { Lens, Optional, Getter } from './Monocle';
import { PathReporter, success as successReporter, failure as failureReporter } from 'io-ts/lib/PathReporter';
import { ThrowReporter } from 'io-ts/lib/ThrowReporter';
export { PathReporter, successReporter, failureReporter, ThrowReporter };
export declare const decodeFromAny: <A, O, I>(type: t.Type<A, O, I>) => (a: any) => A;
/**
 * apply a default value when the value is null.
 * @param type
 * @param defaultValue
 */
export declare const withDefault: <T extends t.Type<any, any, t.mixed>>(type: T, defaultValue: T["_O"]) => t.Type<T["_A"], T["_O"], t.mixed>;
/**
 * The type input is number,The output is Date.
 */
export declare class DateFromNumberType extends t.Type<Date, number> {
    readonly _tag: 'DateFromNumberType';
    constructor();
}
export declare const dateFromNumber: DateFromNumberType;
/**
 * The type input is ISOString,output type is Date.
 */
export declare class DateFromISOStringType extends t.Type<Date, string> {
    readonly _tag: 'DateFromISOStringType';
    constructor();
}
export declare const dateFromISOString: DateFromISOStringType;
export declare type LensesFromProps<P extends t.Props, T extends t.TypeOfProps<P> = t.TypeOfProps<P>> = {
    [K in keyof P]: Lens<T, T[K]>;
};
export declare type OptionalFromNullableProps<P extends t.Props, T extends t.TypeOfPartialProps<P> = t.TypeOfPartialProps<P>> = {
    [K in keyof P]: Optional<T, T[K]>;
};
export declare const lensesFromProps: <P extends t.Props>(props: P) => LensesFromProps<P, t.TypeOfProps<P>>;
export declare const lensesFromNullableProps: <P extends t.Props>(props: P) => OptionalFromNullableProps<P, t.TypeOfPartialProps<P>>;
export declare const integer: t.RefinementType<t.NumberType, number, number, t.mixed>;
export declare const RRuntimeBasic: t.UnionType<(t.StringType | t.NumberType | t.BooleanType | t.RefinementType<t.NumberType, number, number, t.mixed> | DateFromNumberType | DateFromISOStringType)[], string | number | boolean | Date, import("./Compare").TRuntimeBasicType, t.mixed>;
export declare type TRuntimeBasicType = t.TypeOf<typeof RRuntimeBasic>;
export declare const RString: t.LiteralType<"string">;
export declare const RNumber: t.LiteralType<"number">;
export declare const RInteger: t.LiteralType<"integer">;
export declare const RBoolean: t.LiteralType<"boolean">;
export declare const RAny: t.LiteralType<"any">;
export declare const RDateFromISOString: t.LiteralType<"dateFromISOString">;
export declare const RDateFromNumber: t.LiteralType<"dateFromNumber">;
export declare const RBasicType: t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>;
export declare const RBasicAnyType: t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>;
export declare type TBasicType = t.TypeOf<typeof RBasicType>;
export declare type TBasicAnyType = t.TypeOf<typeof RBasicAnyType>;
export declare const RBasicTypeArray: t.TupleType<[t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>], ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], t.mixed>;
export declare const RInputBasicType: t.UnionType<(t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed> | t.TupleType<[t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>], ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber" | ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber" | ["string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber"], t.mixed>;
export declare type TInputBasicType = t.TypeOf<typeof RInputBasicType>;
export declare const RBasicIType: t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>;
export declare type TBasicIType = t.TypeOf<typeof RBasicIType>;
export declare const RTypeArray: t.TupleType<[t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>], [string], [string], t.mixed>;
export declare const RInputType: t.UnionType<(t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed> | t.TupleType<[t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>], [string], [string], t.mixed>)[], string | [string], string | [string], t.mixed>;
export declare type TInputType = t.TypeOf<typeof RInputType>;
export declare const RSchemaType: t.InterfaceType<{
    name: t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>;
    isArray: t.BooleanType;
}, t.TypeOfProps<{
    name: t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>;
    isArray: t.BooleanType;
}>, t.OutputOfProps<{
    name: t.UnionType<(t.StringType | t.UnionType<(t.LiteralType<"any"> | t.UnionType<(t.LiteralType<"string"> | t.LiteralType<"number"> | t.LiteralType<"integer"> | t.LiteralType<"boolean"> | t.LiteralType<"dateFromISOString"> | t.LiteralType<"dateFromNumber">)[], "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", "string" | "number" | "boolean" | "any" | "integer" | "dateFromISOString" | "dateFromNumber", t.mixed>)[], string, string, t.mixed>;
    isArray: t.BooleanType;
}>, t.mixed>;
export declare type TType = t.TypeOf<typeof RSchemaType>;
/**
 * The type input is number,The output is Date.
 */
export declare class TypeFromStringType extends t.Type<TType, TInputType> {
    readonly _tag: 'TypeFromStringType';
    constructor();
}
export declare const typeFromString: TypeFromStringType;
export declare type PropertyType = t.TypeOf<typeof typeFromString>;
export declare const basicTypeRuntime: {
    [P in TBasicAnyType]: t.Type<any>;
};
/**
 * Get type with string
 */
export declare const BasicGetter: Getter<"string" | "number" | "boolean" | "integer" | "dateFromISOString" | "dateFromNumber", t.Type<any, any, t.mixed>>;
export declare const lensesFromIntersection: <A extends t.Props, B extends t.Props>(_intersection: t.IntersectionType<[t.InterfaceType<A, any, any, t.mixed>, t.PartialType<B, any, any, t.mixed>], any, any, t.mixed>) => {
    props: LensesFromProps<A, t.TypeOfProps<A>>;
    nullProps: OptionalFromNullableProps<B, t.TypeOfPartialProps<B>>;
};
