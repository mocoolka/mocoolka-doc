"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPositiveNumberOrZero = function (num) { return Number.isFinite(num) && num >= 0; };
var function_1 = require("./function");
exports.getTypeName = function (value) {
    var typeofObj = typeof value;
    if (typeofObj !== 'object' && typeofObj !== 'function') {
        return typeofObj;
    }
    if (value === null) {
        return 'null';
    }
    if (typeofObj === 'function') {
        return typeofObj;
    }
    return Object.prototype.toString.call(value).slice(8, -1);
};
/*
* Determines whether the passed value is a specific "kind".
* @since v0.1.0
*/
exports.isTypeName = function (strTypeName) { return function (a) { return exports.getTypeName(a) === strTypeName; }; };
/*
* Returns true if the given value is an Argument .
*/
exports.isArguments = exports.isTypeName('Arguments');
/*
 * Determines whether the passed value is an Array.
 */
exports.isArray = function (a) { return exports.getTypeName(a) === 'Array'; };
exports.isArrayLike = function (value) { return value && typeof value.length === 'number'; };
/*
 * Determines whether the passed value is a Boolean instance.
 */
exports.isBoolean = function (a) { return 'boolean' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is a Symbol instance.
 */
exports.isSymbol = function (a) { return typeof a === 'symbol'; };
/*
 * Determines whether the passed value is a Date instance.
 */
exports.isDate = function (a) { return 'Date' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is empty.
 */
exports.isEmpty = function (val) {
    if (val == null) {
        // typeof null == 'object' so we check it first
        return true;
    }
    else if (typeof val === 'string' || exports.isArray(val)) {
        return !val.length;
    }
    else if (typeof val === 'object') {
        return Object.keys(val).length === 0;
    }
    else {
        return true;
    }
};
/*
* Determines whether the passed value is a Error.
*/
exports.isError = function (a) { return 'Error' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is null .
 */
/*
* Determines whether the passed value is Finite.
*/
exports.isFinite = function (val) {
    var is = false;
    if (exports.isString(val) && val !== '') {
        is = Number.isFinite(parseFloat(val));
    }
    else if (exports.isNumber(val)) {
        // need to use isNumber because of Number constructor
        is = Number.isFinite(val);
    }
    return is;
};
/*
* Determines whether the passed value is a Function.
*/
//tslint:disable
exports.isFunction = function (a) { return 'function' === exports.getTypeName(a); };
// tslint:enable
/*
 * Determines whether the passed value is a Integer .
 */
exports.isInteger = function (val) {
    return exports.isNumber(val) && (val % 1 === 0);
};
var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@__mocoolka-iterator__@@';
var getIterator = function (iterable) {
    var iteratorFn = iterable &&
        ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
            iterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
        return iteratorFn;
    }
};
exports.isIterable = function (a) {
    return a && typeof getIterator(a) === 'function';
};
exports.isIterator = function (a) {
    return a && typeof a.next === 'function';
};
/*
* Determines whether the passed value is NaN .
*/
exports.isNaN = function (val) { return !exports.isNumber(val) || $isNaN(Number(val)); };
/*tslint:disable */
var $isNaN = function (val) { return val != val; };
/*
 * Determines whether the passed value is number .
 */
exports.isNumber = function (a) { return 'number' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is a object .
 */
exports.isObject = function (a) { return 'Object' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is a object .
 */
exports.isPlainObject = function (a) { return 'Object' === exports.getTypeName(a); };
/*
 * Determines whether the passed value is a RegExp .
 * Primitive types define immutable values (values, which are incapable of being changed).
 */
exports.isRegExp = function (a) { return 'RegExp' === exports.getTypeName(a); };
exports.isSameType = function (a, b) { return exports.getTypeName(a) === exports.getTypeName(b); };
/*
 * Determines whether the passed value is a string .
 */
exports.isString = function (a) { return typeof a === 'string'; };
exports.isTypedArray = function (ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return (typeof ar === 'object' && /\w+Array]$/.test(Object.prototype.toString.call(ar)));
};
var UNDEF = undefined;
/*
 * Determines whether the passed value is a undefined .
 */
exports.isUndefined = function (val) { return val === UNDEF; };
exports.propExist = function (a, propName) { return a[propName] !== undefined; };
exports.isNull = function (val) { return val === null; };
exports.isNil = function_1.or(exports.isUndefined, exports.isNull);
//# sourceMappingURL=predicate.js.map